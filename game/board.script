local MSG_HIT = hash("hit")

local pegs={"game-peg0","game-peg1","game-peg2","game-peg3"}
local state="show" --show|play
local round=1 --difficulty, determines chain length and (later) number of buttons
local chain_to_show={}
local chain_to_enter={}
local chain_playback_counter=0

--local lbl_prompt = msg.url("#lbl-prompt")



function get_chain(self)
	local ret={}
	local pegs_count=#pegs	
	for i = 1, 3+round, 1 do
		print ("adding "..tostring(i))
		table.insert(ret,math.random(pegs_count))
	end
	for i = 1, #ret do
		print (ret[i])
	end
	return ret
end

function prepare_next_round(self)
	state="show"
	round = round + 1
	label.set_text("#lbl-round", "Round: "..tostring(round))
	chain_to_show=get_chain(self)
	for i=1,#chain_to_show do print ("toshow: "..tostring(chain_to_show[i])) end				
	
	chain_to_enter={}
	for i=1,#chain_to_show do
		table.insert(chain_to_enter,chain_to_show[i])
	end
	for i=1,#chain_to_enter do print ("initial: "..tostring(chain_to_enter[i])) end				
	
	label.set_text("#lbl-prompt", "Memorize the sequence")
end

function reset_game(self) 
	round=0
	local sprites={"Match3Clover","Match3Heart","Match3Moon","Match3Star"}
	for i, v in ipairs(pegs) do		
		print ("setting "..v.." to "..sprites[i])
		msg.post(v, "config", {sprite = sprites[i], order = i})
	end	
	prepare_next_round(self)
end



function init(self)
	msg.post(".", "acquire_input_focus")
	print ("label url is "..msg.url("#lbl-prompt"))
	msg.post(msg.url("#lbl-prompt"), "enable")
	reset_game(self)
end

function final(self)
	msg.post(".", "release_input_focus")
end

function update(self, dt)
	if state=="show" then
		chain_playback_counter = chain_playback_counter + 1/60
		if chain_playback_counter>1 then
			print("showing "..tostring(chain_to_show[1]))
			msg.post(pegs[chain_to_show[1]], "play")
			table.remove(chain_to_show,1)
			chain_playback_counter=0
		end
	end
		
	if #chain_to_show==0 and state=="show" then
		state="play"
		for i, v in ipairs(pegs) do					
			msg.post(v, "activate")
		end	
		label.set_text("#lbl-prompt", "Replay the sequence")	
	end
	
	if state=="play" then		
		if #chain_to_enter==0 then
			prepare_next_round(self)
			print ("current round = "..tostring(round))
			--print ("round won - go to next")
		end
	end
end

function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	if message_id==MSG_HIT then
		print ("receive hit for peg with order = "..message.order)
		if #chain_to_enter>0 then
			if chain_to_enter[1]==message.order then
				print ("ok so far")
				
				for i=1,#chain_to_enter do print ("before: "..tostring(chain_to_enter[i])) end				
				table.remove(chain_to_enter,1)
				for i=1,#chain_to_enter do print ("after: "..tostring(chain_to_enter[i])) end
				
				print ("Remaining pegs: "..tostring(#chain_to_enter))
			end
		end
	end
	--print("message "..hash(message_id).." received on "..tostring(self))
end

function on_input(self, action_id, action)
	if action_id == hash("touch") then
		local pos = vmath.vector3(action.x, action.y, 0)
		go.set_position(pos, "cursor")
	end

	if action_id == hash("escape") and action.released then
		--msg.post("/sound_manager", "play_sample",{sample="button"})
		msg.post("startup:/handler#startup", "show_menu")
	end
	
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
