local game_vars=require("game_vars")

local MSG_HIT = hash("hit")
local MSG_BUTTON_TOUCH = hash("button_touch")

local pegs={"game-peg0","game-peg1","game-peg2","game-peg3"}
--local peg_sounds={"peg_hit_1","peg_hit_2","peg_hit_3","peg_hit_4"}
local peg_sounds={"do","re","mi","fa"}
local state="show" --show|play|countdown - later practice and tutorial
local round=1 --difficulty, determines chain length and (later) number of buttons
local lives=3
local chain_to_show={}
local chain_to_enter={}
local initial_chain={}
local playback_counter=0
local countdown=0

--local lbl_prompt = msg.url("#lbl-prompt")

local function scroll_message(txt)
	label.set_text("scroller#lbl-message",txt)
	local sp=go.get_position("scroller")
	go.set_position(vmath.vector3(650,sp.y,sp.z), "scroller")
	go.animate("scroller", "position.x", go.PLAYBACK_ONCE_FORWARD,-300, go.EASING_INOUTQUAD, 3,0)	
end

local function get_chain(self, initial)
	local ret=initial
	local pegs_count=#pegs	
	if #ret==0 then
		for i = 1, 2+round, 1 do
			--print ("adding "..tostring(i))
			local n=math.random(pegs_count)
			table.insert(ret,n)
		end
	else
		table.insert(ret,math.random(pegs_count))
	end
	--for i = 1, #ret do
		--print (ret[i])
	--end
	return ret
end

local function prepare_next_round(self)
	state="countdown"
	countdown=4
	round = round + 1

	if round % 5 == 0 and lives<5 then
		lives=lives+1
		msg.post("/lives#lives", "set_lives", {lives=lives})
		msg.post("/sound_manager", "play_sample",{sample="powerup"})
	end

	
	label.set_text("#lbl-round", "Round: "..tostring(round))
	--go.set("#lbl-counter", "outline.w", 4)
	--go.set("#lbl-counter", "outline", vmath.vector4(8, 0, 0, 0))
	go.set("#lbl-counter", "outline", vmath.vector4(4, 0, 0, 0))
	go.set("#lbl-counter", "shadow", vmath.vector4(0, 0, 1, 1)) -- Blue outline
	chain_to_show=get_chain(self,initial_chain)
	--for i=1,#chain_to_show do print ("toshow: "..tostring(chain_to_show[i])) end				
	
	chain_to_enter={}
	initial_chain={}
	for i=1,#chain_to_show do
		table.insert(chain_to_enter,chain_to_show[i])
		table.insert(initial_chain,chain_to_show[i])
	end
	--for i=1,#chain_to_enter do print ("initial: "..tostring(chain_to_enter[i])) end				
	
	label.set_text("#lbl-prompt-1", "Memorize the sequence")
	msg.post(msg.url("#lbl-prompt-2"), "enable")
	label.set_text("#lbl-prompt-2", tostring(#chain_to_enter).." moves to memorize")
	label.set_text("#lbl-counter","Round "..tostring(round))
	msg.post(msg.url("#lbl-counter"), "enable")
	go.set("#lbl-counter", "scale.x", 1)
	go.set("#lbl-counter", "scale.y", 1)
end

local function reset_game(self) 
	round=0	
	msg.post("/lives#lives", "set_lives", {lives=lives})
	--local sprites={"Match3Clover","Match3Heart","Match3Moon","Match3Star"}
	local sprites={"peg-red","peg-green","peg-blue","peg-yellow"}
	
	for i, v in ipairs(pegs) do		
		--print ("setting "..v.." to "..sprites[i])
		--msg.post(v, "config", {sprite = sprites[i], order = i, sound = peg_sounds[i]})
		msg.post(v, "config", {order = i, sound = peg_sounds[i]})
	end	
	msg.post("/btn-practice", "config", {cursor="/cursor",text="Enter practice"})
	msg.post("/btn-practice", "disable")
	msg.post("/btn-practice", "deactivate") -- probably not required
	prepare_next_round(self)
end

local function reset_game_board_sprite()
	msg.post("#game-board", "play_animation", {id = hash("board")})	
end

function init(self)
	msg.post(".", "acquire_input_focus")
	--print ("label url is "..msg.url("#lbl-prompt-1"))
	msg.post(msg.url("#lbl-prompt-1"), "enable")
	msg.post(msg.url("#lbl-prompt-2"), "enable")
	reset_game(self)
end

function final(self)
	msg.post(".", "release_input_focus")
end

local function on_countdown_click()
	playback_counter=0
	countdown=countdown-1
	if countdown==0 then
		msg.post(msg.url("#lbl-counter"), "disable")
		state="show"
		print ("state = "..state)
	end
	
	label.set_text("#lbl-counter",tostring(countdown))
	go.set("#lbl-counter", "scale.x", 1)
	go.set("#lbl-counter", "scale.y", 1)

end

function update(self, dt)
	if state=="countdown" then
		if playback_counter ==0 then
			playback_counter=1
			local scale=16
			if countdown==4 then scale=8 end
			go.animate("#lbl-counter", "scale", go.PLAYBACK_ONCE_FORWARD,  vmath.vector3(scale, scale, 1), go.EASING_INOUTQUAD, 1,0,on_countdown_click)
		end	
	end

	if state=="show" then
		playback_counter = playback_counter + dt
		if playback_counter>1 then
			--print("showing "..tostring(chain_to_show[1]))
			msg.post(pegs[chain_to_show[1]], "play")			
			table.remove(chain_to_show,1)
			playback_counter=0
		end
		if #chain_to_show==0 then
			state="play"
			msg.post("/btn-practice", "enable")
			msg.post("/btn-practice", "activate") --probably not required
			print ("state = "..state)
			for i, v in ipairs(pegs) do					
				msg.post(v, "activate")
			end	
			label.set_text("#lbl-prompt-1", "Replay the sequence")	
			msg.post(msg.url("#lbl-prompt-2"), "disable")
		end
	end
		
	
	if state=="play" then
		if #chain_to_enter==0 then
			prepare_next_round(self)
			--print ("current round = "..tostring(round))
			--print ("round won - go to next")
		end
	end
end


function on_message(self, message_id, message, sender)
	if message_id == MSG_BUTTON_TOUCH then
		if sender.path == hash("/btn-practice") and (state=="practice" or state=="play") then
			local txt
			if state=="practice" then 
				state="play" 
				txt="Enter practice" 
				print ("state = "..state)
				reset_game_board_sprite()
				label.set_text("#lbl-prompt-1", "Replay the sequence")	
				msg.post(msg.url("#lbl-prompt-2"), "disable")
			else 
				state="practice" 
				txt="Exit practice" 
				print ("state = "..state)
				msg.post("#game-board", "play_animation", {id = hash("board-gray")})
				label.set_text("#lbl-prompt-1", "In practice mode")
				msg.post(msg.url("#lbl-prompt-2"), "disable")
			end
			msg.post("/btn-practice", "config", {text=txt})
		end		
		
	end
	
	if message_id==MSG_HIT then
		if state=="practice" then
			msg.post("#game-board", "play_animation", {id = hash("board-gray")})
			go.animate("#game-board", "scale", go.PLAYBACK_ONCE_PINGPONG, vmath.vector3(1.5, 1.5, 1), go.EASING_INCUBIC, 0.2, 0, reset_game_board_sprite)			
		end
		if state=="play" then
			print ("receive hit for peg with order = "..message.order)
			if #chain_to_enter>0 then
				if chain_to_enter[1]==message.order then
					--print ("ok so far")
					msg.post("#game-board", "play_animation", {id = hash("board-green")})
					go.animate("#game-board", "scale", go.PLAYBACK_ONCE_PINGPONG, vmath.vector3(1.7, 1.7, 1), go.EASING_INCUBIC, 0.2, 0, reset_game_board_sprite)
					--for i=1,#chain_to_enter do print ("before: "..tostring(chain_to_enter[i])) end
					table.remove(chain_to_enter,1)
					--for i=1,#chain_to_enter do print ("after: "..tostring(chain_to_enter[i])) end
					local remaining=""
					if #chain_to_enter>1 then
						remaining = tostring(#chain_to_enter).." remaining"
					elseif #chain_to_enter==1 then
						remaining = "One to go!"
					else
						remaining = "Well done!"
					end
					--print ("setting text to "..remaining)
					scroll_message(remaining)
					--go.set_position(vmath.vector3(1200, self.initial_pos.y, self.initial_pos.z), self.label_object)
					--print ("Remaining pegs: "..tostring(#chain_to_enter))
				else
					--print ("wrong peg!")
					--msg.post("#game-board", "play_animation", {id = hash("board-red")})
					go.animate("#game-board", "scale", go.PLAYBACK_ONCE_PINGPONG, vmath.vector3(1.7, 1.7, 1), go.EASING_INCUBIC, 0.2, 0, reset_game_board_sprite)
					lives=lives-1
					msg.post("/lives#lives", "set_lives", {lives=lives})
					msg.post("/sound_manager", "play_sample",{sample="error"})
					if lives==0 then
						game_vars.score=round-1 --to be used by the game over collection
						print("game over")
						--back to menu for now, should have proper game over screen, leaderboards etc
						msg.post("startup:/handler#startup", "show_gameover")
					end
				end
			end
		end
	end
	--print("message "..hash(message_id).." received on "..tostring(self))
end

function on_input(self, action_id, action)
	if action_id == hash("touch") then
		local pos = vmath.vector3(action.x, action.y, 0)
		go.set_position(pos, "cursor")
	end

	if action_id == hash("escape") and action.released then
		--msg.post("/sound_manager", "play_sample",{sample="button"})
		msg.post("startup:/handler#startup", "show_menu")
	end	
end